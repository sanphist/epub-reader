<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <title>EPUB é«˜äº®è¯è¡¨é˜…è¯»å™¨</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <!-- å¿…è¦åº“ -->
  <script src="https://unpkg.com/jszip@3.10.1/dist/jszip.min.js"></script>
  <script src="https://unpkg.com/epubjs/dist/epub.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      background: #f4f4f4;
    }
    #top-bar {
      padding: 10px;
      background: #fafafa;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }
    #top-bar > * {
      font-size: 15px;
      padding: 4px 8px;
    }
    #viewer {
      flex-grow: 1;
      width: 100%;
      background: white;
    }
    #progress-bar {
      height: 4px;
      background: #4caf50;
      width: 0%;
      transition: width 0.3s ease;
    }
    #status {
      font-size: 14px;
      padding: 8px 12px;
      background: #fff8dc;
      min-height: 48px;
      overflow-y: auto;
    }
    .dark-mode {
      background-color: #121212 !important;
      color: #eaeaea !important;
    }
    .highlight {
      background-color: yellow;
      padding: 0 2px;
    }
    .dark-mode .highlight {
      background-color: #ffca28;
    }
  </style>
</head>
<body>
  <div id="top-bar">
    <input type="file" id="upload" accept=".epub" />
    <select id="chapters"><option value="">ğŸ“– è¯·é€‰æ‹©ç« èŠ‚</option></select>
    <button id="prev">â¬…ï¸ ä¸Šä¸€é¡µ</button>
    <button id="next">â¡ï¸ ä¸‹ä¸€é¡µ</button>
    <select id="fontSelect">
      <option value="Microsoft YaHei Light">å¾®è½¯é›…é»‘ Light</option>
      <option value="Noto Sans">Noto Sans</option>
      <option value="serif">Serif</option>
      <option value="sans-serif">ç³»ç»Ÿé»˜è®¤</option>
    </select>
    <button id="lineUp">ğŸ”¼ å¢å¤§è¡Œè·</button>
    <button id="lineDown">ğŸ”½ ç¼©å°è¡Œè·</button>
    <button id="modeToggle">ğŸ“– åˆ†é¡µ</button>
    <button id="nightToggle">ğŸŒ™ å¤œé—´</button>
    <input type="file" id="dictUpload" accept=".txt,.xlsx" />
    <select id="colorSelect">
      <option value="yellow">é»„è‰²</option>
      <option value="lightblue">æµ…è“</option>
      <option value="pink">ç²‰è‰²</option>
    </select>
    <label><input type="checkbox" id="caseSensitive"> åŒºåˆ†å¤§å°å†™</label>
  </div>
  <div id="progress-bar"></div>
  <div id="viewer"></div>
  <div id="status">ğŸ“„ Reader åŠ è½½å®Œæ¯•ï¼Œç­‰å¾…ä¸Šä¼  EPUB...</div>
  
  <script>
  if (window.__EPUB_READER_LOADED__) {
    console.log("ğŸŸ¡ é˜…è¯»å™¨å·²åŠ è½½ï¼Œè·³è¿‡é‡å¤æ„å»ºã€‚");
  } else {
    window.__EPUB_READER_LOADED__ = true;
    
    let book, rendition;
    let fontSize = 100, lineHeight = 1.5, isPaged = true;
    let highlights = new Set(), highlightColor = "yellow";
    let caseSensitive = false, isDark = false;
  
    const upload = document.getElementById("upload");
    const viewer = document.getElementById("viewer");
    const status = document.getElementById("status");
    const progressBar = document.getElementById("progress-bar");
    const chapters = document.getElementById("chapters");
    const fontSelect = document.getElementById("fontSelect");
    const lineUp = document.getElementById("lineUp");
    const lineDown = document.getElementById("lineDown");
    const modeToggle = document.getElementById("modeToggle");
    const nightToggle = document.getElementById("nightToggle");
    const dictUpload = document.getElementById("dictUpload");
    const colorSelect = document.getElementById("colorSelect");
    const caseCheckbox = document.getElementById("caseSensitive");
  
    function setProgress(p) { progressBar.style.width = p + "%"; }
    function setStatus(msg) { status.innerText = msg; }
  
    // æ›´æ–°ä¸»é¢˜åˆ°å†…åµŒæ–‡æ¡£ï¼ˆåŒ…æ‹¬å¤œé—´ã€å­—ä½“ã€è¡Œè·ï¼‰
    function applyTheme() {
      if (!rendition) return;
      const theme = {
        "body": {
          "font-family": fontSelect.value,
          "font-size": fontSize + "%",
          "line-height": lineHeight.toString(),
          "background": isDark ? "#121212" : "#ffffff",
          "color": isDark ? "#e0e0e0" : "#000000"
        },
        ".highlight": {
          "background-color": highlightColor
        }
      };
      rendition.themes.register("custom", theme);
      rendition.themes.select("custom");
    }
  
    // è¿‡æ»¤æ— æ•ˆè¯ï¼šåªå…è®¸çº¯è‹±æ–‡å­—æ¯ä¸”é•¿åº¦â‰¥2
    function isValidWord(w) {
      return /^[A-Za-z]{2,}$/.test(w);
    }
  
    // æ™ºèƒ½é«˜äº®ï¼šä»…å¤„ç†æ–‡æœ¬èŠ‚ç‚¹ï¼Œä¸ç ´å HTML ç»“æ„
    function highlightDOMTextNodes(root, words, color, sensitive) {
      if (!words || words.size === 0) return;
      const wordList = Array.from(words).filter(isValidWord).sort((a, b) => b.length - a.length);
      if (wordList.length === 0) return;
      const escaped = wordList.map(w => w.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'));
      let regex;
      try {
        // å°è¯•ä½¿ç”¨ lookbehind/lookaheadï¼ˆéœ€æµè§ˆå™¨æ”¯æŒï¼‰
        regex = new RegExp(`(?<![A-Za-z])(${escaped.join("|")})(?![A-Za-z])`, sensitive ? 'g' : 'gi');
      } catch(e) {
        // é™çº§ä¸ºç®€å•çš„å•è¯è¾¹ç•ŒåŒ¹é…
        regex = new RegExp(`\\b(${escaped.join("|")})\\b`, sensitive ? 'g' : 'gi');
      }
  
      function walk(node) {
        if (node.nodeType === Node.TEXT_NODE) {
          const parent = node.parentNode;
          const frag = document.createDocumentFragment();
          let lastIndex = 0;
          const text = node.textContent;
          let match;
          while ((match = regex.exec(text)) !== null) {
            const before = text.slice(lastIndex, match.index);
            const matchedText = match[0];
            if (before) frag.appendChild(document.createTextNode(before));
            const mark = document.createElement("mark");
            mark.className = "highlight";
            mark.style.backgroundColor = color;
            mark.textContent = matchedText;
            frag.appendChild(mark);
            lastIndex = match.index + matchedText.length;
          }
          if (lastIndex < text.length) {
            frag.appendChild(document.createTextNode(text.slice(lastIndex)));
          }
          if (frag.childNodes.length) {
            parent.replaceChild(frag, node);
          }
        } else if (node.nodeType === Node.ELEMENT_NODE && node.childNodes && !["SCRIPT", "STYLE", "MARK"].includes(node.tagName)) {
          Array.from(node.childNodes).forEach(walk);
        }
      }
      walk(root);
    }
  
    upload.addEventListener("change", function () {
      const file = this.files[0];
      if (!file) return;
      setProgress(10);
      setStatus("ğŸ“¥ åŠ è½½ EPUBï¼š" + file.name);
      chapters.innerHTML = '<option value="">ğŸ“– è¯·é€‰æ‹©ç« èŠ‚</option>';
      viewer.innerHTML = "";
  
      book = ePub(file);
      rendition = book.renderTo(viewer, { flow: isPaged ? "paginated" : "scrolled", width: "100%", height: "100%" });
  
      const storageKey = "epub-pos-" + file.name;
  
      // æ¯æ¬¡ç« èŠ‚æ¸²æŸ“å®Œæˆååº”ç”¨ä¸»é¢˜ä¸é«˜äº®
      rendition.on("rendered", section => {
        const iframe = viewer.querySelector("iframe");
        if (!iframe) return;
        const doc = iframe.contentDocument;
        applyTheme();
        highlightDOMTextNodes(doc.body, highlights, highlightColor, caseSensitive);
      });
  
      book.ready.then(() => {
        const fallbackSpine = book.spine?.get(0)?.href || book.package?.spine?.[0]?.href || null;
        const displayTarget = localStorage.getItem(storageKey) || fallbackSpine;
        rendition.display(displayTarget);
        rendition.on("relocated", loc => localStorage.setItem(storageKey, loc.start.href));
        return book.navigation.loaded;
      }).then(nav => {
        if (!nav || !nav.toc || nav.toc.length === 0) {
          setStatus("âš ï¸ æœ¬ä¹¦æ²¡æœ‰ç›®å½•ï¼Œå·²å°è¯•ç›´æ¥åŠ è½½æ­£æ–‡ã€‚");
          return;
        }
        nav.toc.forEach((item, i) => {
          const opt = document.createElement("option");
          opt.value = item.href;
          opt.textContent = item.label || `ç« èŠ‚ ${i+1}`;
          chapters.appendChild(opt);
        });
        setStatus("âœ… EPUB åŠ è½½æˆåŠŸï¼");
      }).catch(err => {
        console.error(err);
        setStatus("âŒ åŠ è½½å¤±è´¥: " + err.message);
      });
  
      setProgress(100);
    });
  
    document.getElementById("prev").onclick = () => rendition && rendition.prev();
    document.getElementById("next").onclick = () => rendition && rendition.next();
    chapters.onchange = () => rendition.display(chapters.value);
    fontSelect.onchange = applyTheme;
    lineUp.onclick = () => { lineHeight += 0.1; applyTheme(); };
    lineDown.onclick = () => { lineHeight = Math.max(1, lineHeight - 0.1); applyTheme(); };
    colorSelect.onchange = () => { highlightColor = colorSelect.value; applyTheme(); };
    caseCheckbox.onchange = () => { caseSensitive = caseCheckbox.checked; };
    nightToggle.onclick = () => { isDark = !isDark; applyTheme(); };
    modeToggle.onclick = () => {
      isPaged = !isPaged;
      modeToggle.innerText = isPaged ? "ğŸ“– åˆ†é¡µ" : "ğŸ“œ æ»šåŠ¨";
      if (rendition) rendition.flow(isPaged ? "paginated" : "scrolled");
    };
  
    dictUpload.addEventListener("change", async function () {
      const file = this.files[0];
      if (!file) return;
      highlights.clear();
      if (file.name.endsWith(".txt")) {
        const text = await file.text();
        text.split(/\r?\n/).forEach(word => {
          const trimmed = word.trim();
          if (isValidWord(trimmed)) highlights.add(trimmed);
        });
      } else if (file.name.endsWith(".xlsx")) {
        const data = await file.arrayBuffer();
        const wb = XLSX.read(data, { type: "array" });
        const sheet = wb.Sheets[wb.SheetNames[0]];
        const rows = XLSX.utils.sheet_to_json(sheet, { header: 1 });
        rows.forEach(row => {
          const word = row[0];
          if (word && typeof word === "string" && isValidWord(word.trim())) {
            highlights.add(word.trim());
          }
        });
      }
      setStatus(`âœ… å·²åŠ è½½è¯è¡¨ï¼š${highlights.size} é¡¹`);
      if (rendition) {
        rendition.display(rendition.location.start.href);
      }
    });
  
  } // ç»“æŸåˆå§‹åŒ–å—
  </script>
</body>
</html>
